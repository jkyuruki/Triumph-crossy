<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crossy Practice (Isometric)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #111;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      touch-action: none; /* we handle touch via pointer events */
      background: #222;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #hud {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
      pointer-events: none;
    }

    #score-display span {
      display: block;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 18px;
      text-shadow: 0 0 6px #000;
      pointer-events: none;
      white-space: pre-line;
    }

    #cashout-container {
      position: absolute;
      bottom: 12px;
      right: 12px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    #cashout-label {
      font-size: 12px;
      text-shadow: 0 0 4px #000;
      max-width: 180px;
      text-align: right;
    }

    #cashout-button {
      position: relative;
      width: 150px;
      height: 40px;
      border-radius: 20px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      pointer-events: auto;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }

    #cashout-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      border-radius: 20px;
      background: rgba(0, 255, 128, 0.6);
      pointer-events: none;
      transition: width 0.05s linear;
    }

    #cashout-text {
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="score-display">
      <span id="current-score">Score: 0</span>
      <span id="best-score">Best: 0</span>
    </div>
  </div>

  <div id="message"></div>

  <div id="cashout-container">
    <div id="cashout-label">Hold to cash out (~2.5s). If you die, you get 0.</div>
    <div id="cashout-button">
      <div id="cashout-fill"></div>
      <div id="cashout-text">CASH OUT</div>
    </div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const msgEl = document.getElementById('message');
  const scoreEl = document.getElementById('current-score');
  const bestEl = document.getElementById('best-score');
  const cashBtn = document.getElementById('cashout-button');
  const cashFill = document.getElementById('cashout-fill');

  // Grid
  const COLS = 9;
  const ROWS = 15;

  let tileSize = 32;          // logical tile size (still used for logic/clamps)
  let isoTileW = 64;          // pixel width of iso diamond
  let isoTileH = 32;          // pixel height of iso diamond
  let isoOriginX = 0;         // origin of grid in screen space
  let isoOriginY = 0;

  // Game state
  let lanes = []; // lanes[0] is the nearest/bottom lane
  let player = null;
  let gameState = 'playing'; // 'playing' | 'dead' | 'cashed'
  let score = 0;
  let bestScore = 0;
  let lastRunScore = 0;

  // Standing still / danger
  const STAND_STILL_LIMIT = 7; // seconds
  const CASHOUT_HOLD_TIME = 2.5; // seconds
  let timeSinceMove = 0;
  let dangerAlpha = 0;

  // Cashout hold
  let cashOutHolding = false;
  let cashOutHoldTime = 0;

  // Lane segment control (to favor stretches)
  let segmentType = 'grass';
  let segmentLength = 0;

  // Forward scrolling threshold
  const FORWARD_SCROLL_THRESHOLD = 7;

  let lastTime = 0;

  // === Resize & isometric setup ===
  function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;

    tileSize = Math.min(canvas.width / COLS, canvas.height / ROWS);

    // Choose iso tile size relative to canvas
    const span = COLS + ROWS;
    isoTileW = (canvas.width * 0.9) / span * 2; // a bit generous in width
    isoTileH = isoTileW * 0.55;

    // Place the "middle" of the grid somewhat lower than center
    const midU = (COLS - 1) / 2;
    const midV = (ROWS - 1) / 2;

    const desiredY = canvas.height * 0.65; // grid "center" a bit low
    isoOriginX = canvas.width / 2;
    isoOriginY = desiredY - (midU + midV) * isoTileH / 2;
  }

  window.addEventListener('resize', resize);

  function toIso(u, v) {
    // u, v: grid coords where v=0 is nearest to camera
    const x = isoOriginX + (u - v) * isoTileW / 2;
    const y = isoOriginY + (u + v) * isoTileH / 2;
    return { x, y };
  }

  function randRange(min, max) {
    return min + Math.random() * (max - min);
  }

  function chooseNextLaneType() {
    // Weighted lane types: obstacles a bit more common than grass
    const weights = [
      { type: 'grass', w: 1 },
      { type: 'road',  w: 3 },
      { type: 'river', w: 3 },
      { type: 'rail',  w: 1 }
    ];

    // Maintain stretches: keep current type for at least 2 rows
    if (segmentLength < 2) {
      return segmentType;
    }

    // Limit very long stretches
    if (segmentLength >= 5) {
      const others = weights.filter(x => x.type !== segmentType);
      const total = others.reduce((a, b) => a + b.w, 0);
      let r = Math.random() * total;
      for (const o of others) {
        if (r < o.w) return o.type;
        r -= o.w;
      }
    }

    const total = weights.reduce((a, b) => a + b.w, 0);
    let r = Math.random() * total;
    for (const w of weights) {
      if (r < w.w) return w.type;
      r -= w.w;
    }
    return 'grass';
  }

  function createGrassLane() {
    return {
      type: 'grass',
      speed: 0,
      dir: 0,
      objects: [],
      train: null,
      decoration: Math.random() < 0.4 ? 'bushes' : null
    };
  }

  function createRoadLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = randRange(2.2, 3.6);
    const cars = [];
    const carCount = 3 + Math.floor(Math.random() * 3); // 3-5

    for (let i = 0; i < carCount; i++) {
      const length = randRange(0.8, 1.4);
      const startX = Math.random() * COLS;
      cars.push({ x: startX, length });
    }

    return {
      type: 'road',
      speed,
      dir,
      objects: cars,
      train: null,
      decoration: null
    };
  }

  function createRiverLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = randRange(1.5, 2.5);
    const logs = [];
    const logCount = 3 + Math.floor(Math.random() * 2); // 3-4

    for (let i = 0; i < logCount; i++) {
      const width = randRange(1.6, 2.4);
      const startX = Math.random() * COLS;
      logs.push({ x: startX, width });
    }

    return {
      type: 'river',
      speed,
      dir,
      objects: logs,
      train: null,
      decoration: null
    };
  }

  function createRailLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = 9;
    const trainWidth = 6;
    const cooldown = randRange(3, 6);

    return {
      type: 'rail',
      speed,
      dir,
      objects: [],
      train: {
        active: false,
        x: dir > 0 ? -trainWidth - 2 : COLS + trainWidth + 2,
        width: trainWidth,
        cooldown,
        timer: randRange(1, cooldown)
      },
      decoration: null
    };
  }

  function createLaneOfType(t) {
    if (t === 'grass') return createGrassLane();
    if (t === 'road')  return createRoadLane();
    if (t === 'river') return createRiverLane();
    if (t === 'rail')  return createRailLane();
    return createGrassLane();
  }

  function generateInitialWorld() {
    lanes = [];
    segmentType = 'grass';
    segmentLength = 0;

    for (let i = 0; i < ROWS; i++) {
      let lane;
      if (i < 3) {
        lane = createGrassLane();
      } else {
        const t = chooseNextLaneType();
        if (t === segmentType) {
          segmentLength++;
        } else {
          segmentType = t;
          segmentLength = 1;
        }
        lane = createLaneOfType(segmentType);
      }
      lanes.push(lane);
    }

    player = {
      x: Math.floor(COLS / 2),
      y: 1,    // row index, lanes[0] is nearest to camera
    };

    score = 0;
    lastRunScore = 0;
    timeSinceMove = 0;
    dangerAlpha = 0;
    cashOutHoldTime = 0;
    cashOutHolding = false;
    gameState = 'playing';

    setMessage(
      "Swipe or tap to move (tap = forward).\n" +
      "Hold CASH OUT (~2.5s) to bank your score.\n" +
      "If you die, you get 0."
    );
  }

  function shiftWorldForward() {
    lanes.shift();
    const t = chooseNextLaneType();
    if (t === segmentType) {
      segmentLength++;
    } else {
      segmentType = t;
      segmentLength = 1;
    }
    lanes.push(createLaneOfType(segmentType));
    player.y -= 1;
  }

  function worldUpdate(dt) {
    if (gameState === 'playing') {
      timeSinceMove += dt;
      dangerAlpha = Math.min(timeSinceMove / STAND_STILL_LIMIT, 1);
      if (timeSinceMove >= STAND_STILL_LIMIT) {
        die("The world caught up to you!");
      }
    }

    // Update lanes
    for (let i = 0; i < lanes.length; i++) {
      const lane = lanes[i];

      if (lane.type === 'road') {
        for (const car of lane.objects) {
          car.x += lane.speed * lane.dir * dt;
          if (lane.dir > 0 && car.x - car.length / 2 > COLS + 2) {
            car.x = -car.length / 2 - Math.random() * 3;
          } else if (lane.dir < 0 && car.x + car.length / 2 < -2) {
            car.x = COLS + car.length / 2 + Math.random() * 3;
          }
        }
      } else if (lane.type === 'river') {
        for (const log of lane.objects) {
          log.x += lane.speed * lane.dir * dt;
          if (lane.dir > 0 && log.x - log.width / 2 > COLS + 2) {
            log.x = -log.width / 2 - Math.random() * 3;
          } else if (lane.dir < 0 && log.x + log.width / 2 < -2) {
            log.x = COLS + log.width / 2 + Math.random() * 3;
          }
        }
      } else if (lane.type === 'rail') {
        const train = lane.train;
        if (train) {
          train.timer -= dt;
          if (!train.active) {
            if (train.timer <= 0) {
              train.active = true;
              train.x = lane.dir > 0 ? -train.width - 2 : COLS + train.width + 2;
            }
          } else {
            train.x += lane.speed * lane.dir * dt;
            if (lane.dir > 0 && train.x - train.width / 2 > COLS + 4) {
              train.active = false;
              train.timer = train.cooldown;
            } else if (lane.dir < 0 && train.x + train.width / 2 < -4) {
              train.active = false;
              train.timer = train.cooldown;
            }
          }
        }
      }
    }

    // River â€“ carry player with logs
    if (gameState === 'playing') {
      const lane = lanes[player.y];
      if (lane && lane.type === 'river') {
        let onPlatform = false;
        for (const log of lane.objects) {
          const half = log.width / 2;
          if (player.x >= log.x - half - 0.3 && player.x <= log.x + half + 0.3) {
            onPlatform = true;
            player.x += lane.speed * lane.dir * dt;
          }
        }
        if (!onPlatform) {
          die("You fell in the water!");
        }
      }
    }

    // Cash-out hold bar
    if (gameState === 'playing' && cashOutHolding) {
      cashOutHoldTime += dt;
      const progress = Math.max(0, Math.min(1, cashOutHoldTime / CASHOUT_HOLD_TIME));
      cashFill.style.width = (progress * 100).toFixed(1) + '%';
      if (cashOutHoldTime >= CASHOUT_HOLD_TIME) {
        doCashOut();
      }
    } else {
      cashOutHoldTime = 0;
      cashFill.style.width = '0%';
    }

    // Horizontal out-of-bounds => death
    if (gameState === 'playing') {
      if (player.x < -0.4 || player.x > COLS - 1 + 0.4) {
        die("You fell off the edge!");
      }
    }

    // Car/train collisions
    if (gameState === 'playing') {
      const lane = lanes[player.y];
      if (lane) {
        if (lane.type === 'road') {
          for (const car of lane.objects) {
            if (Math.abs(car.x - player.x) < (car.length / 2 + 0.35)) {
              die("You got hit by a car!");
              break;
            }
          }
        } else if (lane.type === 'rail') {
          const train = lane.train;
          if (train && train.active) {
            if (Math.abs(train.x - player.x) < (train.width / 2 + 0.7)) {
              die("You got hit by a train!");
            }
          }
        }
      }
    }
  }

  // === Drawing (isometric 2.5D) ===
  function drawIsoTile(u, v, color) {
    const { x, y } = toIso(u + 0.5, v + 0.5);
    const hw = isoTileW / 2;
    const hh = isoTileH / 2;

    ctx.beginPath();
    ctx.moveTo(x,     y - hh);
    ctx.lineTo(x + hw, y);
    ctx.lineTo(x,     y + hh);
    ctx.lineTo(x - hw, y);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw from far (top row) to near (bottom row) for correct overlap
    for (let y = ROWS - 1; y >= 0; y--) {
      const lane = lanes[y];

      // 1) Ground tiles
      for (let x = 0; x < COLS; x++) {
        let color;
        if (lane.type === 'grass') {
          color = '#2f8a33';
        } else if (lane.type === 'road') {
          color = '#2c2c2c';
        } else if (lane.type === 'river') {
          color = '#205b97';
        } else if (lane.type === 'rail') {
          color = '#5a4330';
        } else {
          color = '#333';
        }
        drawIsoTile(x, y, color);
      }

      // 2) Lane decorations & obstacles

      // Grass bushes
      if (lane.type === 'grass' && lane.decoration === 'bushes') {
        for (let x = 0; x < COLS; x++) {
          if (Math.random() < 0.2) {
            const pos = toIso(x + 0.5, y + 0.5);
            const w = isoTileW * 0.35;
            const h = isoTileH * 0.6;
            ctx.fillStyle = '#1f5c21';
            ctx.fillRect(pos.x - w / 2, pos.y - h, w, h);
          }
        }
      }

      // Road center line
      if (lane.type === 'road') {
        ctx.save();
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        for (let x = 0; x <= COLS; x++) {
          const pos = toIso(x, y + 0.5);
          if (x === 0) ctx.moveTo(pos.x, pos.y);
          else ctx.lineTo(pos.x, pos.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // Cars (upright 3D-ish blocks)
        for (const car of lane.objects) {
          const pos = toIso(car.x, y + 0.5);
          const w = car.length * isoTileW * 0.75;
          const h = isoTileH * 1.2;

          ctx.fillStyle = '#d9534f';
          ctx.fillRect(pos.x - w / 2, pos.y - h, w, h);

          // simple "roof"
          ctx.fillStyle = '#f4d03f';
          ctx.fillRect(pos.x - w / 3, pos.y - h * 0.9, (2 * w) / 3, h * 0.3);
        }
      }

      // River logs
      if (lane.type === 'river') {
        for (const log of lane.objects) {
          const pos = toIso(log.x, y + 0.5);
          const w = log.width * isoTileW * 0.8;
          const h = isoTileH * 0.4;
          ctx.fillStyle = '#c28b3b';
          ctx.fillRect(pos.x - w / 2, pos.y - h / 2, w, h);
        }
      }

      // Rail tracks + train
      if (lane.type === 'rail') {
        // Tracks
        ctx.save();
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;

        // Two rails: slightly offset in "depth"
        ctx.beginPath();
        for (let x = 0; x <= COLS; x++) {
          const pos1 = toIso(x, y + 0.4);
          if (x === 0) ctx.moveTo(pos1.x, pos1.y);
          else ctx.lineTo(pos1.x, pos1.y);
        }
        ctx.stroke();

        ctx.beginPath();
        for (let x = 0; x <= COLS; x++) {
          const pos2 = toIso(x, y + 0.6);
          if (x === 0) ctx.moveTo(pos2.x, pos2.y);
          else ctx.lineTo(pos2.x, pos2.y);
        }
        ctx.stroke();
        ctx.restore();

        // Train
        const train = lane.train;
        if (train && train.active) {
          const pos = toIso(train.x, y + 0.5);
          const w = train.width * isoTileW * 0.85;
          const h = isoTileH * 1.8;

          ctx.fillStyle = '#cccccc';
          ctx.fillRect(pos.x - w / 2, pos.y - h, w, h);

          // windows
          ctx.fillStyle = '#444';
          const windowH = h * 0.25;
          ctx.fillRect(pos.x - w / 2 + 8, pos.y - h + 10, w - 16, windowH);

          // headlight-ish
          ctx.fillStyle = '#ff4444';
          const hx = lane.dir > 0 ? pos.x + w / 2 - 12 : pos.x - w / 2 + 12;
          ctx.beginPath();
          ctx.arc(hx, pos.y - h / 2, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // 3) Player (draw on its lane)
      if (player && player.y === y) {
        const pos = toIso(player.x + 0.5, player.y + 0.5);
        const w = isoTileW * 0.45;
        const h = isoTileH * 2.0;

        // body
        ctx.fillStyle = '#ffee77';
        ctx.fillRect(pos.x - w / 2, pos.y - h, w, h * 0.7);

        // head
        const headH = h * 0.35;
        ctx.fillStyle = '#fff9c4';
        ctx.fillRect(pos.x - w / 2, pos.y - h - headH * 0.1, w, headH);

        // eyes
        ctx.fillStyle = '#333';
        ctx.fillRect(pos.x - w * 0.2, pos.y - h + headH * 0.1, 3, 3);
        ctx.fillRect(pos.x + w * 0.2 - 3, pos.y - h + headH * 0.1, 3, 3);
      }
    }

    // Danger overlay (standing still)
    if (dangerAlpha > 0) {
      const alpha = Math.min(dangerAlpha * 0.8, 0.8);
      ctx.fillStyle = `rgba(255,0,0,${alpha.toFixed(3)})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Cash-out aura around button
    if (gameState === 'playing' && cashOutHolding) {
      const rectCanvas = canvas.getBoundingClientRect();
      const rectBtn = cashBtn.getBoundingClientRect();
      const cx = (rectBtn.left + rectBtn.right) / 2 - rectCanvas.left;
      const cy = (rectBtn.top + rectBtn.bottom) / 2 - rectCanvas.top;
      const radius = rectBtn.width * 0.7;
      const progress = Math.max(0, Math.min(1, cashOutHoldTime / CASHOUT_HOLD_TIME));

      ctx.save();
      ctx.globalAlpha = 0.2 + 0.3 * progress;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = '#00ff99';
      ctx.fill();
      ctx.restore();
    }
  }

  // === Game state helpers ===
  function die(reason) {
    if (gameState !== 'playing') return;
    gameState = 'dead';
    lastRunScore = 0; // no cash out => 0
    setMessage(reason + "\nYou get 0.\nTap anywhere to restart.");
    cashOutHolding = false;
  }

  function doCashOut() {
    if (gameState !== 'playing') return;
    lastRunScore = score;
    if (lastRunScore > bestScore) bestScore = lastRunScore;
    gameState = 'cashed';
    cashOutHolding = false;
    setMessage("You cashed out with " + lastRunScore + "!\nTap anywhere to play again.");
    updateScoreDisplay();
  }

  function setMessage(text) {
    msgEl.textContent = text || '';
  }

  function updateScoreDisplay() {
    const displayScore = (gameState === 'dead') ? 0 : score;
    scoreEl.textContent = "Score: " + displayScore;
    bestEl.textContent = "Best: " + bestScore;
  }

  function tryMove(dx, dy) {
    if (gameState === 'dead' || gameState === 'cashed') {
      generateInitialWorld();
      updateScoreDisplay();
      return;
    }
    if (gameState !== 'playing') return;

    const newX = player.x + dx;
    const newY = player.y + dy;

    if (newX < 0 || newX > COLS - 1) return;
    if (newY < 0 || newY > ROWS - 1) return;

    player.x = newX;
    player.y = newY;

    // reset stand-still timer
    timeSinceMove = 0;
    dangerAlpha = 0;

    if (dy > 0) {
      // forward
      score++;
      if (score > bestScore) bestScore = score;
      updateScoreDisplay();

      if (player.y > FORWARD_SCROLL_THRESHOLD) {
        shiftWorldForward();
      }
    }
  }

  // === Input: keyboard (desktop) ===
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowUp' || e.key === 'w') {
      tryMove(0, 1);
    } else if (e.key === 'ArrowDown' || e.key === 's') {
      tryMove(0, -1);
    } else if (e.key === 'ArrowLeft' || e.key === 'a') {
      tryMove(-1, 0);
    } else if (e.key === 'ArrowRight' || e.key === 'd') {
      tryMove(1, 0);
    }
  });

  // === Input: unified pointer events (fixes double-move bug) ===
  let touchStartX = 0;
  let touchStartY = 0;
  let touchActive = false;

  function canvasPointerDown(clientX, clientY) {
    touchStartX = clientX;
    touchStartY = clientY;
    touchActive = true;
  }

  function canvasPointerUp(clientX, clientY) {
    if (!touchActive) return;
    touchActive = false;

    const dx = clientX - touchStartX;
    const dy = clientY - touchStartY;
    const distSq = dx * dx + dy * dy;
    const TAP_THRESHOLD = 20;

    if (distSq < TAP_THRESHOLD * TAP_THRESHOLD) {
      // Tap: forward only
      tryMove(0, 1);
      return;
    }

    // Swipe: whichever axis dominates
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) tryMove(1, 0);
      else        tryMove(-1, 0);
    } else {
      if (dy > 0) tryMove(0, -1); // swipe down
      else        tryMove(0, 1);  // swipe up
    }
  }

  canvas.addEventListener('pointerdown', e => {
    if (e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen') {
      e.preventDefault();
      canvasPointerDown(e.clientX, e.clientY);
    }
  });

  canvas.addEventListener('pointerup', e => {
    if (e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen') {
      e.preventDefault();
      canvasPointerUp(e.clientX, e.clientY);
    }
  });

  canvas.addEventListener('pointercancel', e => {
    touchActive = false;
  });

  // Tap on canvas when dead/cashed to restart
  canvas.addEventListener('click', () => {
    if (gameState === 'dead' || gameState === 'cashed') {
      generateInitialWorld();
      updateScoreDisplay();
    }
  });

  // === Cash-out button: unified pointer events ===
  function startCashOutHold() {
    if (gameState !== 'playing') return;
    cashOutHolding = true;
    cashOutHoldTime = 0;
    cashFill.style.width = '0%';
  }

  function endCashOutHold() {
    cashOutHolding = false;
  }

  cashBtn.addEventListener('pointerdown', e => {
    if (e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen') {
      e.preventDefault();
      e.stopPropagation();
      startCashOutHold();
    }
  });

  cashBtn.addEventListener('pointerup', e => {
    if (e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen') {
      e.preventDefault();
      e.stopPropagation();
      endCashOutHold();
    }
  });

  cashBtn.addEventListener('pointerleave', e => {
    endCashOutHold();
  });

  cashBtn.addEventListener('pointercancel', e => {
    endCashOutHold();
  });

  // === Main loop ===
  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    worldUpdate(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // Init
  resize();
  generateInitialWorld();
  updateScoreDisplay();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
