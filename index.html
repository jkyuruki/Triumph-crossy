<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crossy Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #111;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      touch-action: none; /* we handle touch */
      background: #222;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #hud {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
      pointer-events: none;
    }

    #score-display span {
      display: block;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 18px;
      text-shadow: 0 0 6px #000;
      pointer-events: none;
    }

    #cashout-container {
      position: absolute;
      bottom: 12px;
      right: 12px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    #cashout-label {
      font-size: 12px;
      text-shadow: 0 0 4px #000;
      max-width: 160px;
      text-align: right;
    }

    #cashout-button {
      position: relative;
      width: 140px;
      height: 40px;
      border-radius: 20px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      pointer-events: auto;
      -webkit-user-select: none;
      user-select: none;
    }

    #cashout-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      border-radius: 20px;
      background: rgba(0, 255, 128, 0.6);
      pointer-events: none;
      transition: width 0.05s linear;
    }

    #cashout-text {
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="score-display">
      <span id="current-score">Score: 0</span>
      <span id="best-score">Best: 0</span>
    </div>
  </div>

  <div id="message"></div>

  <div id="cashout-container">
    <div id="cashout-label">Hold to cash out (~2.5s)</div>
    <div id="cashout-button">
      <div id="cashout-fill"></div>
      <div id="cashout-text">CASH OUT</div>
    </div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const msgEl = document.getElementById('message');
  const scoreEl = document.getElementById('current-score');
  const bestEl = document.getElementById('best-score');
  const cashBtn = document.getElementById('cashout-button');
  const cashFill = document.getElementById('cashout-fill');

  // Grid settings
  const COLS = 9;
  const ROWS = 15;

  let tileSize = 32;
  let offsetX = 0;
  let offsetY = 0;

  // Game state
  let lanes = []; // bottom -> top
  let player = null;
  let gameState = 'playing'; // 'playing' | 'dead' | 'cashed'
  let score = 0;
  let bestScore = 0;
  let lastRunScore = 0;

  const STAND_STILL_LIMIT = 7; // seconds
  const CASHOUT_HOLD_TIME = 2.5; // seconds
  let timeSinceMove = 0;
  let dangerAlpha = 0;

  let cashOutHolding = false;
  let cashOutHoldTime = 0;

  let lastTime = 0;

  // For random lane segments (to favor stretches)
  let segmentType = 'grass';
  let segmentLength = 0;

  // Player initial row threshold before world scrolls
  const FORWARD_SCROLL_THRESHOLD = 7;

  function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;

    tileSize = Math.min(canvas.width / COLS, canvas.height / ROWS);
    const gridWidth = tileSize * COLS;
    const gridHeight = tileSize * ROWS;
    offsetX = (canvas.width - gridWidth) / 2;
    offsetY = (canvas.height - gridHeight) / 2;
  }

  window.addEventListener('resize', resize);

  function randRange(min, max) {
    return min + Math.random() * (max - min);
  }

  function choice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // Lane generator
  function createGrassLane() {
    return {
      type: 'grass',
      speed: 0,
      dir: 0,
      objects: [],
      train: null,
      decoration: Math.random() < 0.5 ? 'bushes' : null
    };
  }

  function createRoadLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = randRange(2.2, 3.6); // tiles per second
    const cars = [];

    const carCount = 3 + Math.floor(Math.random() * 3); // 3-5 cars
    for (let i = 0; i < carCount; i++) {
      const length = randRange(0.8, 1.4);
      const startX = Math.random() * COLS;
      cars.push({
        x: startX,
        length: length
      });
    }

    return {
      type: 'road',
      speed,
      dir,
      objects: cars,
      train: null,
      decoration: null
    };
  }

  function createRiverLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = randRange(1.5, 2.5);
    const logs = [];
    const logCount = 3 + Math.floor(Math.random() * 2); // 3-4

    for (let i = 0; i < logCount; i++) {
      const width = randRange(1.6, 2.4);
      const startX = Math.random() * COLS;
      logs.push({
        x: startX,
        width
      });
    }

    return {
      type: 'river',
      speed,
      dir,
      objects: logs,
      train: null,
      decoration: null
    };
  }

  function createRailLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = 9; // fast
    const trainWidth = 6; // tiles
    const cooldown = randRange(3, 6); // seconds between trains

    return {
      type: 'rail',
      speed,
      dir,
      objects: [],
      train: {
        active: false,
        x: dir > 0 ? -trainWidth - 2 : COLS + trainWidth + 2,
        width: trainWidth,
        cooldown,
        timer: randRange(1, cooldown)
      },
      decoration: null
    };
  }

  function chooseNextLaneType() {
    // We weight lane types to favor obstacles
    // grass:1, road:3, river:3, rail:1
    const weights = [
      { type: 'grass', w: 1 },
      { type: 'road', w: 3 },
      { type: 'river', w: 3 },
      { type: 'rail', w: 1 }
    ];

    // Force stretches: if segmentLength < 2, keep current type
    if (segmentLength < 2) {
      return segmentType;
    }

    // Also mildly cap super long segments
    if (segmentLength >= 5) {
      // force a different type
      const other = weights.filter(x => x.type !== segmentType);
      const total = other.reduce((a, b) => a + b.w, 0);
      let r = Math.random() * total;
      for (const o of other) {
        if (r < o.w) return o.type;
        r -= o.w;
      }
    }

    const total = weights.reduce((a, b) => a + b.w, 0);
    let r = Math.random() * total;
    for (const w of weights) {
      if (r < w.w) return w.type;
      r -= w.w;
    }
    return 'grass';
  }

  function createLaneOfType(t) {
    if (t === 'grass') return createGrassLane();
    if (t === 'road') return createRoadLane();
    if (t === 'river') return createRiverLane();
    if (t === 'rail') return createRailLane();
    return createGrassLane();
  }

  function generateInitialWorld() {
    lanes = [];
    segmentType = 'grass';
    segmentLength = 0;

    // Start with some safe grass at bottom
    for (let i = 0; i < ROWS; i++) {
      let lane;
      if (i < 3) {
        lane = createGrassLane();
      } else {
        const t = chooseNextLaneType();
        if (t === segmentType) {
          segmentLength++;
        } else {
          segmentType = t;
          segmentLength = 1;
        }
        lane = createLaneOfType(segmentType);
      }
      lanes.push(lane);
    }

    // Player starting position
    player = {
      x: Math.floor(COLS / 2),
      y: 1, // row index (from bottom)
      width: 0.8,
      height: 0.8
    };

    score = 0;
    timeSinceMove = 0;
    dangerAlpha = 0;
    cashOutHolding = false;
    cashOutHoldTime = 0;
    lastRunScore = 0;
    gameState = 'playing';
    setMessage('Swipe or tap to move. Tap = forward.\nHold CASH OUT to bank your score.');
  }

  function shiftWorldForward() {
    // Remove bottom lane, add new lane at top
    lanes.shift();

    const t = chooseNextLaneType();
    if (t === segmentType) {
      segmentLength++;
    } else {
      segmentType = t;
      segmentLength = 1;
    }
    const newLane = createLaneOfType(segmentType);
    lanes.push(newLane);

    // Keep player visually in place
    player.y -= 1;
  }

  function worldUpdate(dt) {
    if (gameState === 'playing') {
      timeSinceMove += dt;
      dangerAlpha = Math.min(timeSinceMove / STAND_STILL_LIMIT, 1);
      if (timeSinceMove >= STAND_STILL_LIMIT) {
        die("The world caught up to you!");
      }
    }

    // Update lanes
    for (let i = 0; i < lanes.length; i++) {
      const lane = lanes[i];

      if (lane.type === 'road') {
        for (const car of lane.objects) {
          car.x += lane.speed * lane.dir * dt;
          if (lane.dir > 0 && car.x - car.length / 2 > COLS + 2) {
            car.x = -car.length / 2 - Math.random() * 3;
          } else if (lane.dir < 0 && car.x + car.length / 2 < -2) {
            car.x = COLS + car.length / 2 + Math.random() * 3;
          }
        }
      } else if (lane.type === 'river') {
        for (const log of lane.objects) {
          log.x += lane.speed * lane.dir * dt;
          if (lane.dir > 0 && log.x - log.width / 2 > COLS + 2) {
            log.x = -log.width / 2 - Math.random() * 3;
          } else if (lane.dir < 0 && log.x + log.width / 2 < -2) {
            log.x = COLS + log.width / 2 + Math.random() * 3;
          }
        }
      } else if (lane.type === 'rail') {
        const train = lane.train;
        if (train) {
          train.timer -= dt;
          if (!train.active) {
            if (train.timer <= 0) {
              train.active = true;
              train.x = lane.dir > 0 ? -train.width - 2 : COLS + train.width + 2;
            }
          } else {
            train.x += lane.speed * lane.dir * dt;
            if (lane.dir > 0 && train.x - train.width / 2 > COLS + 4) {
              train.active = false;
              train.timer = train.cooldown;
            } else if (lane.dir < 0 && train.x + train.width / 2 < -4) {
              train.active = false;
              train.timer = train.cooldown;
            }
          }
        }
      }
    }

    // River: carry player if on a log
    if (gameState === 'playing') {
      let onPlatform = false;
      const lane = lanes[player.y];
      if (lane && lane.type === 'river') {
        for (const log of lane.objects) {
          const half = log.width / 2;
          if (player.x >= log.x - half - 0.3 && player.x <= log.x + half + 0.3) {
            onPlatform = true;
            player.x += lane.speed * lane.dir * dt;
          }
        }
        // After moving with log, if not on any, you drown
        if (!onPlatform) {
          die("You fell in the water!");
        }
      }
    }

    // Cash out hold
    if (gameState === 'playing' && cashOutHolding) {
      cashOutHoldTime += dt;
      const progress = Math.max(0, Math.min(1, cashOutHoldTime / CASHOUT_HOLD_TIME));
      cashFill.style.width = (progress * 100).toFixed(1) + '%';
      if (cashOutHoldTime >= CASHOUT_HOLD_TIME) {
        doCashOut();
      }
    } else {
      // reset bar visually when not holding or not playing
      if (!cashOutHolding || gameState !== 'playing') {
        cashOutHoldTime = 0;
        cashFill.style.width = '0%';
      }
    }

    // Clamp player horizontally; falling off edges kills
    if (gameState === 'playing') {
      if (player.x < -0.4 || player.x > COLS - 1 + 0.4) {
        die("You fell off the edge!");
      }
    }

    // Collisions with cars & trains
    if (gameState === 'playing') {
      const lane = lanes[player.y];
      if (lane) {
        if (lane.type === 'road') {
          for (const car of lane.objects) {
            if (Math.abs(car.x - player.x) < (car.length / 2 + 0.35)) {
              die("You got hit by a car!");
              break;
            }
          }
        } else if (lane.type === 'rail') {
          const train = lane.train;
          if (train && train.active) {
            if (Math.abs(train.x - player.x) < (train.width / 2 + 0.7)) {
              die("You got hit by a train!");
            }
          }
        }
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw lanes
    for (let i = 0; i < lanes.length; i++) {
      const lane = lanes[i];
      const y = i;

      const px = offsetX;
      const py = canvas.height - offsetY - (y + 1) * tileSize;
      const w = tileSize * COLS;
      const h = tileSize;

      // Background color per lane type
      if (lane.type === 'grass') {
        ctx.fillStyle = '#2d7d2f';
      } else if (lane.type === 'road') {
        ctx.fillStyle = '#303030';
      } else if (lane.type === 'river') {
        ctx.fillStyle = '#204f8a';
      } else if (lane.type === 'rail') {
        ctx.fillStyle = '#4a3a2a';
      } else {
        ctx.fillStyle = '#333';
      }
      ctx.fillRect(px, py, w, h);

      // Extra decorations
      if (lane.type === 'grass' && lane.decoration === 'bushes') {
        ctx.fillStyle = '#215d23';
        for (let b = 0; b < 3; b++) {
          const bx = px + (0.5 + Math.random() * (COLS - 1)) * tileSize;
          const by = py + 0.2 * tileSize;
          ctx.fillRect(bx, by, tileSize * 0.4, tileSize * 0.6);
        }
      }

      if (lane.type === 'road') {
        // lane markings
        ctx.strokeStyle = '#707070';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.moveTo(px, py + h / 2);
        ctx.lineTo(px + w, py + h / 2);
        ctx.stroke();
        ctx.setLineDash([]);

        // cars
        for (const car of lane.objects) {
          const cx = px + (car.x + 0.5) * tileSize;
          const cy = py + h * 0.1;
          const cw = car.length * tileSize;
          const ch = h * 0.8;
          ctx.fillStyle = '#d9534f';
          ctx.fillRect(cx - cw / 2, cy, cw, ch);
        }
      }

      if (lane.type === 'river') {
        // waves
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        for (let j = 0; j < COLS; j++) {
          ctx.fillRect(px + j * tileSize, py + h * 0.2, tileSize * 0.5, 2);
          ctx.fillRect(px + j * tileSize + tileSize * 0.3, py + h * 0.6, tileSize * 0.5, 2);
        }
        // logs
        for (const log of lane.objects) {
          const lx = px + (log.x + 0.5) * tileSize;
          const lw = log.width * tileSize;
          const ly = py + h * 0.1;
          const lh = h * 0.8;
          ctx.fillStyle = '#c28b3b';
          ctx.fillRect(lx - lw / 2, ly, lw, lh);
        }
      }

      if (lane.type === 'rail') {
        // draw tracks
        ctx.fillStyle = '#3b2c20';
        ctx.fillRect(px, py + h * 0.25, w, h * 0.5);
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(px, py + h * 0.3);
        ctx.lineTo(px + w, py + h * 0.3);
        ctx.moveTo(px, py + h * 0.7);
        ctx.lineTo(px + w, py + h * 0.7);
        ctx.stroke();

        // ties
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        for (let j = 0; j < COLS * 2; j++) {
          const tx = px + (j / 2) * tileSize;
          ctx.beginPath();
          ctx.moveTo(tx, py + h * 0.25);
          ctx.lineTo(tx, py + h * 0.75);
          ctx.stroke();
        }

        // train
        const train = lane.train;
        if (train && train.active) {
          const tx = px + (train.x + 0.5) * tileSize;
          const tw = train.width * tileSize;
          const ty = py + h * 0.05;
          const th = h * 0.9;
          ctx.fillStyle = '#bbbbbb';
          ctx.fillRect(tx - tw / 2, ty, tw, th);
          ctx.fillStyle = '#444';
          ctx.fillRect(tx - tw / 2 + 8, ty + 8, tw - 16, th / 2);
          // little red light
          ctx.fillStyle = '#ff4444';
          const lightX = train.dir > 0 ? tx + tw / 2 - 10 : tx - tw / 2 + 10;
          ctx.beginPath();
          ctx.arc(lightX, ty + th / 2, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Draw player
    if (player) {
      const px = offsetX + (player.x + 0.5) * tileSize;
      const py = canvas.height - offsetY - (player.y + 1) * tileSize;
      const w = player.width * tileSize;
      const h = player.height * tileSize;
      ctx.fillStyle = '#ffee77';
      ctx.fillRect(px - w / 2, py + tileSize * 0.1, w, h * 0.9);
      // head
      ctx.fillStyle = '#fff9c4';
      const headH = h * 0.4;
      ctx.fillRect(px - w / 2, py, w, headH);
      // eyes
      ctx.fillStyle = '#333';
      ctx.fillRect(px - w * 0.25, py + headH * 0.3, 3, 3);
      ctx.fillRect(px + w * 0.25 - 3, py + headH * 0.3, 3, 3);
    }

    // Danger overlay (standing still)
    if (dangerAlpha > 0) {
      const alpha = Math.min(dangerAlpha * 0.8, 0.8);
      ctx.fillStyle = `rgba(255,0,0,${alpha.toFixed(3)})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Cash-out progress light aura around button (optional)
    if (gameState === 'playing' && cashOutHolding) {
      const rect = cashBtn.getBoundingClientRect();
      const cx = (rect.left + rect.right) / 2 - canvas.getBoundingClientRect().left;
      const cy = (rect.top + rect.bottom) / 2 - canvas.getBoundingClientRect().top;
      const radius = rect.width * 0.7;
      const progress = Math.max(0, Math.min(1, cashOutHoldTime / CASHOUT_HOLD_TIME));

      ctx.save();
      ctx.globalAlpha = 0.2 + 0.3 * progress;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = '#00ff99';
      ctx.fill();
      ctx.restore();
    }
  }

  function die(reason) {
    if (gameState !== 'playing') return;
    gameState = 'dead';
    lastRunScore = 0; // by design: no cash out = 0
    setMessage(reason + "\nYou get 0 (no cash out).\nTap anywhere to restart.");
    cashOutHolding = false;
  }

  function doCashOut() {
    if (gameState !== 'playing') return;
    lastRunScore = score;
    bestScore = Math.max(bestScore, lastRunScore);
    updateScoreDisplay();
    gameState = 'cashed';
    cashOutHolding = false;
    setMessage("You cashed out with " + lastRunScore + "!\nTap anywhere to play again.");
  }

  function setMessage(text) {
    msgEl.textContent = text || '';
  }

  function updateScoreDisplay() {
    const displayScore = (gameState === 'dead') ? 0 : score;
    scoreEl.textContent = "Score: " + displayScore;
    bestEl.textContent = "Best: " + bestScore;
  }

  function tryMove(dx, dy) {
    if (gameState === 'dead' || gameState === 'cashed') {
      // any move/tap after death/cashout restarts
      generateInitialWorld();
      updateScoreDisplay();
      return;
    }

    if (gameState !== 'playing') return;

    const newX = player.x + dx;
    const newY = player.y + dy;

    if (newX < 0 || newX > COLS - 1) return;
    if (newY < 0 || newY > ROWS - 1) return;

    player.x = newX;
    player.y = newY;

    // reset stand-still timer
    timeSinceMove = 0;
    dangerAlpha = 0;

    if (dy > 0) {
      // moved forward
      score++;
      if (score > bestScore) bestScore = score;
      updateScoreDisplay();

      if (player.y > FORWARD_SCROLL_THRESHOLD) {
        shiftWorldForward();
      }
    }
  }

  // Input: keyboard (for desktop)
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowUp' || e.key === 'w') {
      tryMove(0, 1);
    } else if (e.key === 'ArrowDown' || e.key === 's') {
      tryMove(0, -1);
    } else if (e.key === 'ArrowLeft' || e.key === 'a') {
      tryMove(-1, 0);
    } else if (e.key === 'ArrowRight' || e.key === 'd') {
      tryMove(1, 0);
    }
  });

  // Input: touch/mouse swipes on canvas
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  let touchActive = false;

  function canvasPointerDown(clientX, clientY) {
    touchStartX = clientX;
    touchStartY = clientY;
    touchStartTime = performance.now();
    touchActive = true;
  }

  function canvasPointerUp(clientX, clientY) {
    if (!touchActive) return;
    touchActive = false;
    const dx = clientX - touchStartX;
    const dy = clientY - touchStartY;
    const distSq = dx * dx + dy * dy;

    const TAP_THRESHOLD = 20; // pixels
    if (distSq < TAP_THRESHOLD * TAP_THRESHOLD) {
      // tap => forward
      tryMove(0, 1);
      return;
    }

    // swipe direction
    if (Math.abs(dx) > Math.abs(dy)) {
      // horizontal swipe
      if (dx > 0) {
        tryMove(1, 0);
      } else {
        tryMove(-1, 0);
      }
    } else {
      // vertical swipe
      if (dy > 0) {
        // swipe down
        tryMove(0, -1);
      } else {
        // swipe up
        tryMove(0, 1);
      }
    }
  }

  canvas.addEventListener('mousedown', e => {
    canvasPointerDown(e.clientX, e.clientY);
  });

  canvas.addEventListener('mouseup', e => {
    canvasPointerUp(e.clientX, e.clientY);
  });

  canvas.addEventListener('touchstart', e => {
    if (e.touches.length > 0) {
      const t = e.touches[0];
      canvasPointerDown(t.clientX, t.clientY);
    }
  }, { passive: true });

  canvas.addEventListener('touchend', e => {
    const t = e.changedTouches[0];
    canvasPointerUp(t.clientX, t.clientY);
  }, { passive: true });

  // Also allow tap anywhere on message screen to restart
  canvas.addEventListener('click', () => {
    if (gameState === 'dead' || gameState === 'cashed') {
      generateInitialWorld();
      updateScoreDisplay();
    }
  });

  // Cash-out button events
  function startCashOutHold() {
    if (gameState !== 'playing') return;
    cashOutHolding = true;
    cashOutHoldTime = 0;
    cashFill.style.width = '0%';
  }

  function endCashOutHold() {
    cashOutHolding = false;
  }

  cashBtn.addEventListener('mousedown', e => {
    e.stopPropagation();
    startCashOutHold();
  });

  cashBtn.addEventListener('mouseup', e => {
    e.stopPropagation();
    endCashOutHold();
  });

  cashBtn.addEventListener('mouseleave', e => {
    endCashOutHold();
  });

  cashBtn.addEventListener('touchstart', e => {
    e.stopPropagation();
    startCashOutHold();
  }, { passive: false });

  cashBtn.addEventListener('touchend', e => {
    e.stopPropagation();
    endCashOutHold();
  }, { passive: false });

  cashBtn.addEventListener('touchcancel', e => {
    e.stopPropagation();
    endCashOutHold();
  }, { passive: false });

  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    worldUpdate(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // Init
  resize();
  generateInitialWorld();
  updateScoreDisplay();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
