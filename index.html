<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crossy Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #111;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      touch-action: none; /* we manually handle gestures */
      background: #222;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #hud {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
      pointer-events: none;
    }

    #score-display span {
      display: block;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 18px;
      text-shadow: 0 0 6px #000;
      pointer-events: none;
      white-space: pre-line;
    }

    #cashout-container {
      position: absolute;
      bottom: 12px;
      right: 12px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    #cashout-label {
      font-size: 12px;
      text-shadow: 0 0 4px #000;
      max-width: 200px;
      text-align: right;
    }

    #cashout-button {
      position: relative;
      width: 150px;
      height: 40px;
      border-radius: 20px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      pointer-events: auto;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }

    #cashout-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      border-radius: 20px;
      background: rgba(0, 255, 128, 0.6);
      pointer-events: none;
      transition: width 0.05s linear;
    }

    #cashout-text {
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="score-display">
      <span id="current-score">Score: 0</span>
      <span id="best-score">Best: 0</span>
    </div>
  </div>

  <div id="message"></div>

  <div id="cashout-container">
    <div id="cashout-label">
      Hold to cash out (~1.5s). If you die before cashing out, you get 0.
    </div>
    <div id="cashout-button">
      <div id="cashout-fill"></div>
      <div id="cashout-text">CASH OUT</div>
    </div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const msgEl = document.getElementById('message');
  const scoreEl = document.getElementById('current-score');
  const bestEl = document.getElementById('best-score');
  const cashBtn = document.getElementById('cashout-button');
  const cashFill = document.getElementById('cashout-fill');

  // Grid
  const COLS = 9;
  const ROWS = 15;

  let tileSize = 32;
  let offsetX = 0;
  let offsetY = 0;

  // Game state
  let lanes = []; // lanes[0] is bottom
  let player = null;
  let gameState = 'playing'; // 'playing' | 'dead' | 'cashed'
  let score = 0;
  let bestScore = 0;
  let lastRunScore = 0;

  const STAND_STILL_LIMIT = 7;   // seconds before world catches up
  const CASHOUT_HOLD_TIME = 1.5; // seconds to hold cashout button

  let timeSinceMove = 0;
  let dangerAlpha = 0;

  let cashOutHolding = false;
  let cashOutHoldTime = 0;

  // Lane segment control (favor stretches)
  let segmentType = 'grass';
  let segmentLength = 0;

  const FORWARD_SCROLL_THRESHOLD = 7;

  // Track forward progress so only "new land" counts
  let progressIndex = 0;      // current forward distance from start
  let furthestProgress = 0;   // max distance reached this run (score)

  let lastTime = 0;

  function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;

    // Keep tiles reasonably large on phone
    tileSize = Math.floor(Math.min(canvas.width / COLS, canvas.height / ROWS));
    tileSize = Math.max(tileSize, 24);

    const gridWidth  = tileSize * COLS;
    const gridHeight = tileSize * ROWS;

    offsetX = (canvas.width  - gridWidth)  / 2;
    offsetY = (canvas.height - gridHeight) / 2;
  }

  window.addEventListener('resize', resize);

  function randRange(min, max) {
    return min + Math.random() * (max - min);
  }

  // Lane generators
  function createGrassLane() {
    return {
      type: 'grass',
      speed: 0,
      dir: 0,
      objects: [],
      train: null,
      decoration: Math.random() < 0.4 ? 'bushes' : null
    };
  }

  function createRoadLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = randRange(2.2, 3.6); // tiles/s
    const cars = [];
    const carCount = 3 + Math.floor(Math.random() * 3); // 3-5

    for (let i = 0; i < carCount; i++) {
      const length = randRange(0.8, 1.4);
      const startX = Math.random() * COLS;
      cars.push({ x: startX, length });
    }

    return {
      type: 'road',
      speed,
      dir,
      objects: cars,
      train: null,
      decoration: null
    };
  }

  function createRiverLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = randRange(1.5, 2.5);
    const logs = [];
    const logCount = 3 + Math.floor(Math.random() * 2); // 3-4

    for (let i = 0; i < logCount; i++) {
      const width = randRange(1.6, 2.4);
      const startX = Math.random() * COLS;
      logs.push({ x: startX, width });
    }

    return {
      type: 'river',
      speed,
      dir,
      objects: logs,
      train: null,
      decoration: null
    };
  }

  function createRailLane() {
    const dir = Math.random() < 0.5 ? 1 : -1;
    const speed = 9;
    const trainWidth = 6;
    const cooldown = randRange(3, 6);

    return {
      type: 'rail',
      speed,
      dir,
      objects: [],
      train: {
        active: false,
        x: dir > 0 ? -trainWidth - 2 : COLS + trainWidth + 2,
        width: trainWidth,
        cooldown,
        timer: randRange(1, cooldown)
      },
      decoration: null
    };
  }

  function chooseNextLaneType() {
    // Weighted: favor obstacles
    const weights = [
      { type: 'grass', w: 1 },
      { type: 'road',  w: 3 },
      { type: 'river', w: 3 },
      { type: 'rail',  w: 1 }
    ];

    // Keep at least 2-lane segments of same type
    if (segmentLength < 2) {
      return segmentType;
    }

    // After 5+ in a row, force a change
    if (segmentLength >= 5) {
      const others = weights.filter(x => x.type !== segmentType);
      const total = others.reduce((a, b) => a + b.w, 0);
      let r = Math.random() * total;
      for (const o of others) {
        if (r < o.w) return o.type;
        r -= o.w;
      }
    }

    const total = weights.reduce((a, b) => a + b.w, 0);
    let r = Math.random() * total;
    for (const w of weights) {
      if (r < w.w) return w.type;
      r -= w.w;
    }
    return 'grass';
  }

  function createLaneOfType(t) {
    if (t === 'grass') return createGrassLane();
    if (t === 'road')  return createRoadLane();
    if (t === 'river') return createRiverLane();
    if (t === 'rail')  return createRailLane();
    return createGrassLane();
  }

  function generateInitialWorld() {
    lanes = [];
    segmentType = 'grass';
    segmentLength = 0;

    for (let i = 0; i < ROWS; i++) {
      let lane;
      if (i < 3) {
        lane = createGrassLane(); // safe starting zone
      } else {
        const t = chooseNextLaneType();
        if (t === segmentType) {
          segmentLength++;
        } else {
          segmentType = t;
          segmentLength = 1;
        }
        lane = createLaneOfType(segmentType);
      }
      lanes.push(lane);
    }

    player = {
      x: Math.floor(COLS / 2),
      y: 1,
      width: 0.8,
      height: 0.8
    };

    // progress / scoring reset
    progressIndex = 0;
    furthestProgress = 0;
    score = 0;
    lastRunScore = 0;

    // standing still timer
    timeSinceMove = 0;
    dangerAlpha = 0;

    // cashout
    cashOutHolding = false;
    cashOutHoldTime = 0;

    gameState = 'playing';

    setMessage(
      "Swipe or tap to move (tap = forward).\n" +
      "Only NEW forward tiles reduce the danger.\n" +
      "Hold CASH OUT (~1.5s) to bank your score.\n" +
      "If you die, you get 0."
    );
  }

  function shiftWorldForward() {
    lanes.shift();
    const t = chooseNextLaneType();
    if (t === segmentType) {
      segmentLength++;
    } else {
      segmentType = t;
      segmentLength = 1;
    }
    lanes.push(createLaneOfType(segmentType));

    player.y -= 1;
  }

  function worldUpdate(dt) {
    if (gameState === 'playing') {
      timeSinceMove += dt;
      dangerAlpha = Math.min(timeSinceMove / STAND_STILL_LIMIT, 1);
      if (timeSinceMove >= STAND_STILL_LIMIT) {
        die("The world caught up to you!");
      }
    }

    // Move lane objects
    for (let i = 0; i < lanes.length; i++) {
      const lane = lanes[i];

      if (lane.type === 'road') {
        for (const car of lane.objects) {
          car.x += lane.speed * lane.dir * dt;
          if (lane.dir > 0 && car.x - car.length / 2 > COLS + 2) {
            car.x = -car.length / 2 - Math.random() * 3;
          } else if (lane.dir < 0 && car.x + car.length / 2 < -2) {
            car.x = COLS + car.length / 2 + Math.random() * 3;
          }
        }
      } else if (lane.type === 'river') {
        for (const log of lane.objects) {
          log.x += lane.speed * lane.dir * dt;
          if (lane.dir > 0 && log.x - log.width / 2 > COLS + 2) {
            log.x = -log.width / 2 - Math.random() * 3;
          } else if (lane.dir < 0 && log.x + log.width / 2 < -2) {
            log.x = COLS + log.width / 2 + Math.random() * 3;
          }
        }
      } else if (lane.type === 'rail') {
        const train = lane.train;
        if (train) {
          train.timer -= dt;
          if (!train.active) {
            if (train.timer <= 0) {
              train.active = true;
              train.x = lane.dir > 0 ? -train.width - 2 : COLS + train.width + 2;
            }
          } else {
            train.x += lane.speed * lane.dir * dt;
            if (lane.dir > 0 && train.x - train.width / 2 > COLS + 4) {
              train.active = false;
              train.timer = train.cooldown;
            } else if (lane.dir < 0 && train.x + train.width / 2 < -4) {
              train.active = false;
              train.timer = train.cooldown;
            }
          }
        }
      }
    }

    // River: logs move under you, and they carry you if you're on them.
    if (gameState === 'playing') {
      const lane = lanes[player.y];
      if (lane && lane.type === 'river') {
        let onPlatform = false;
        let carry = 0;

        for (const log of lane.objects) {
          const half = log.width / 2;
          // small margin so visuals & collision feel aligned
          if (player.x >= log.x - half - 0.1 && player.x <= log.x + half + 0.1) {
            onPlatform = true;
            carry = lane.speed * lane.dir * dt;
            break;
          }
        }

        if (onPlatform) {
          // ride the log
          player.x += carry;
        } else {
          // nothing under you: drown
          die("You fell in the water!");
        }
      }
    }

    // Cashout progress
    if (gameState === 'playing' && cashOutHolding) {
      cashOutHoldTime += dt;
      const progress = Math.max(0, Math.min(1, cashOutHoldTime / CASHOUT_HOLD_TIME));
      cashFill.style.width = (progress * 100).toFixed(1) + '%';
      if (cashOutHoldTime >= CASHOUT_HOLD_TIME) {
        doCashOut();
      }
    } else {
      cashOutHoldTime = 0;
      cashFill.style.width = '0%';
    }

    // Clamp x slightly to avoid crazy drift
    if (player) {
      player.x = Math.max(-1, Math.min(COLS, player.x));
    }

    // Off left/right => dead
    if (gameState === 'playing') {
      if (player.x < -0.4 || player.x > COLS - 1 + 0.4) {
        die("You fell off the edge!");
      }
    }

    // Collisions with cars/trains (cleaner hit boxes)
    if (gameState === 'playing') {
      const lane = lanes[player.y];
      if (lane) {
        if (lane.type === 'road') {
          for (const car of lane.objects) {
            const carHalf = car.length / 2;
            const playerHalf = player.width / 2;
            if (Math.abs(car.x - player.x) < carHalf + playerHalf * 0.6) {
              die("You got hit by a car!");
              break;
            }
          }
        } else if (lane.type === 'rail') {
          const train = lane.train;
          if (train && train.active) {
            const trainHalf = train.width / 2;
            const playerHalf = player.width / 2;
            if (Math.abs(train.x - player.x) < trainHalf + playerHalf * 0.4) {
              die("You got hit by a train!");
            }
          }
        }
      }
    }
  }

  // Drawing
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < ROWS; y++) {
      const lane = lanes[y];
      const px = offsetX;
      const py = canvas.height - offsetY - (y + 1) * tileSize;
      const w = tileSize * COLS;
      const h = tileSize;

      // Lane base color
      if (lane.type === 'grass') {
        ctx.fillStyle = '#2d7d2f';
      } else if (lane.type === 'road') {
        ctx.fillStyle = '#303030';
      } else if (lane.type === 'river') {
        ctx.fillStyle = '#204f8a';
      } else if (lane.type === 'rail') {
        ctx.fillStyle = '#4a3a2a';
      } else {
        ctx.fillStyle = '#333';
      }
      ctx.fillRect(px, py, w, h);

      // Decorations / obstacles
      if (lane.type === 'grass' && lane.decoration === 'bushes') {
        ctx.fillStyle = '#215d23';
        for (let b = 0; b < 3; b++) {
          const bx = px + (0.5 + Math.random() * (COLS - 1)) * tileSize;
          const by = py + 0.2 * tileSize;
          ctx.fillRect(bx, by, tileSize * 0.4, tileSize * 0.6);
        }
      }

      if (lane.type === 'road') {
        // center line
        ctx.strokeStyle = '#707070';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.moveTo(px, py + h / 2);
        ctx.lineTo(px + w, py + h / 2);
        ctx.stroke();
        ctx.setLineDash([]);

        // cars
        for (const car of lane.objects) {
          const cx = px + (car.x + 0.5) * tileSize;
          const cy = py + h * 0.1;
          const cw = car.length * tileSize;
          const ch = h * 0.8;
          ctx.fillStyle = '#d9534f';
          ctx.fillRect(cx - cw / 2, cy, cw, ch);
        }
      }

      if (lane.type === 'river') {
        // simple waves
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        for (let j = 0; j < COLS; j++) {
          ctx.fillRect(px + j * tileSize, py + h * 0.2, tileSize * 0.5, 2);
          ctx.fillRect(px + j * tileSize + tileSize * 0.3, py + h * 0.6, tileSize * 0.5, 2);
        }
        // logs
        for (const log of lane.objects) {
          const lx = px + (log.x + 0.5) * tileSize;
          const lw = log.width * tileSize;
          const ly = py + h * 0.1;
          const lh = h * 0.8;
          ctx.fillStyle = '#c28b3b';
          ctx.fillRect(lx - lw / 2, ly, lw, lh);
        }
      }

      if (lane.type === 'rail') {
        // track base
        ctx.fillStyle = '#3b2c20';
        ctx.fillRect(px, py + h * 0.25, w, h * 0.5);
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(px, py + h * 0.3);
        ctx.lineTo(px + w, py + h * 0.3);
        ctx.moveTo(px, py + h * 0.7);
        ctx.lineTo(px + w, py + h * 0.7);
        ctx.stroke();

        // ties
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        for (let j = 0; j < COLS * 2; j++) {
          const tx = px + (j / 2) * tileSize;
          ctx.beginPath();
          ctx.moveTo(tx, py + h * 0.25);
          ctx.lineTo(tx, py + h * 0.75);
          ctx.stroke();
        }

        // train
        const train = lane.train;
        if (train && train.active) {
          const tx = px + (train.x + 0.5) * tileSize;
          const tw = train.width * tileSize;
          const ty = py + h * 0.05;
          const th = h * 0.9;
          ctx.fillStyle = '#bbbbbb';
          ctx.fillRect(tx - tw / 2, ty, tw, th);
          ctx.fillStyle = '#444';
          ctx.fillRect(tx - tw / 2 + 8, ty + 8, tw - 16, th / 2);
          ctx.fillStyle = '#ff4444';
          const lightX = lanes[y].dir > 0 ? tx + tw / 2 - 10 : tx - tw / 2 + 10;
          ctx.beginPath();
          ctx.arc(lightX, ty + th / 2, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Draw player
    if (player) {
      const px = offsetX + (player.x + 0.5) * tileSize;
      const py = canvas.height - offsetY - (player.y + 1) * tileSize;
      const w = player.width * tileSize;
      const h = player.height * tileSize;
      ctx.fillStyle = '#ffee77';
      ctx.fillRect(px - w / 2, py + tileSize * 0.1, w, h * 0.9);
      // head
      ctx.fillStyle = '#fff9c4';
      const headH = h * 0.4;
      ctx.fillRect(px - w / 2, py, w, headH);
      // eyes
      ctx.fillStyle = '#333';
      ctx.fillRect(px - w * 0.25, py + headH * 0.3, 3, 3);
      ctx.fillRect(px + w * 0.25 - 3, py + headH * 0.3, 3, 3);
    }

    // Danger overlay
    if (dangerAlpha > 0) {
      const alpha = Math.min(dangerAlpha * 0.8, 0.8);
      ctx.fillStyle = `rgba(255,0,0,${alpha.toFixed(3)})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Cashout aura
    if (gameState === 'playing' && cashOutHolding) {
      const rectCanvas = canvas.getBoundingClientRect();
      const rectBtn = cashBtn.getBoundingClientRect();
      const cx = (rectBtn.left + rectBtn.right) / 2 - rectCanvas.left;
      const cy = (rectBtn.top + rectBtn.bottom) / 2 - rectCanvas.top;
      const radius = rectBtn.width * 0.7;
      const progress = Math.max(0, Math.min(1, cashOutHoldTime / CASHOUT_HOLD_TIME));

      ctx.save();
      ctx.globalAlpha = 0.2 + 0.3 * progress;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fillStyle = '#00ff99';
      ctx.fill();
      ctx.restore();
    }
  }

  function die(reason) {
    if (gameState !== 'playing') return;
    gameState = 'dead';
    lastRunScore = 0; // no cash out
    setMessage(reason + "\nYou get 0.\nTap/swipe to restart.");
    cashOutHolding = false;
  }

  function doCashOut() {
    if (gameState !== 'playing') return;
    lastRunScore = score;
    if (lastRunScore > bestScore) bestScore = lastRunScore;
    gameState = 'cashed';
    cashOutHolding = false;
    setMessage("You cashed out with " + lastRunScore + "!\nTap/swipe to play again.");
    updateScoreDisplay();
  }

  function setMessage(text) {
    msgEl.textContent = text || '';
  }

  function updateScoreDisplay() {
    const displayScore = (gameState === 'dead') ? 0 : score;
    scoreEl.textContent = "Score: " + displayScore;
    bestEl.textContent = "Best: " + bestScore;
  }

  function tryMove(dx, dy) {
    if (gameState === 'dead' || gameState === 'cashed') {
      generateInitialWorld();
      updateScoreDisplay();
      return;
    }
    if (gameState !== 'playing') return;

    // Snap to nearest tile horizontally before applying side move
    const baseX = Math.round(player.x);
    const newX = baseX + dx;
    const newY = player.y + dy;

    if (newX < 0 || newX > COLS - 1) return;
    if (newY < 0 || newY > ROWS - 1) return;

    player.x = newX;
    player.y = newY;

    // Movement effects
    if (dy > 0) {
      // Forward in grid-space
      progressIndex += 1;

      // Only if we've gone further than ever before this run:
      if (progressIndex > furthestProgress) {
        furthestProgress = progressIndex;
        score = furthestProgress;

        // Reduce, not reset, the danger timer
        timeSinceMove = Math.max(0, timeSinceMove - 3);

        if (score > bestScore) bestScore = score;
        updateScoreDisplay();

        if (player.y > FORWARD_SCROLL_THRESHOLD) {
          shiftWorldForward();
        }
      }

      // Forward into already visited tiles: no score, no timer change
    } else if (dy < 0) {
      // Backwards reduces current position index but not score (furthestProgress stays)
      progressIndex = Math.max(0, progressIndex - 1);
      // No effect on timeSinceMove
    } else {
      // Sideways: no effect on progressIndex or timer
    }
  }

  // Keyboard (desktop)
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowUp' || e.key === 'w')      tryMove(0, 1);
    else if (e.key === 'ArrowDown' || e.key === 's')  tryMove(0, -1);
    else if (e.key === 'ArrowLeft' || e.key === 'a')  tryMove(-1, 0);
    else if (e.key === 'ArrowRight' || e.key === 'd') tryMove(1, 0);
  });

  // Pointer-based gestures (fixes double-fire on taps)
  let pointerActive = false;
  let pointerStartX = 0;
  let pointerStartY = 0;

  function handlePointerDown(e) {
    if (!(e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen')) return;
    e.preventDefault();
    pointerActive = true;
    pointerStartX = e.clientX;
    pointerStartY = e.clientY;
  }

  function handlePointerUp(e) {
    if (!pointerActive) return;
    if (!(e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen')) return;
    e.preventDefault();
    pointerActive = false;

    const dx = e.clientX - pointerStartX;
    const dy = e.clientY - pointerStartY;
    const distSq = dx * dx + dy * dy;
    const TAP_THRESHOLD = 20; // px

    if (distSq < TAP_THRESHOLD * TAP_THRESHOLD) {
      // TAP: forward only
      tryMove(0, 1);
      return;
    }

    // SWIPE: dominant axis decides direction
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) tryMove(1, 0);
      else        tryMove(-1, 0);
    } else {
      if (dy > 0) tryMove(0, -1); // swipe down
      else        tryMove(0, 1);  // swipe up
    }
  }

  canvas.addEventListener('pointerdown', handlePointerDown);
  canvas.addEventListener('pointerup', handlePointerUp);
  canvas.addEventListener('pointercancel', () => { pointerActive = false; });

  // Cash-out button pointer events
  function startCashOutHold() {
    if (gameState !== 'playing') return;
    cashOutHolding = true;
    cashOutHoldTime = 0;
    cashFill.style.width = '0%';
  }

  function endCashOutHold() {
    cashOutHolding = false;
  }

  cashBtn.addEventListener('pointerdown', e => {
    if (!(e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen')) return;
    e.preventDefault();
    e.stopPropagation();
    startCashOutHold();
  });

  cashBtn.addEventListener('pointerup', e => {
    if (!(e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen')) return;
    e.preventDefault();
    e.stopPropagation();
    endCashOutHold();
  });

  cashBtn.addEventListener('pointerleave', endCashOutHold);
  cashBtn.addEventListener('pointercancel', endCashOutHold);

  // Main loop
  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    worldUpdate(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // Init
  resize();
  generateInitialWorld();
  updateScoreDisplay();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
